---
title: "Géometries de mondes abstraits"
subtitle: "Régionalisation d'un semis de population en fonction d'une distance"
date: "2024-11-18"
date-format: iso
author: "Claude Grasland"
lang: fr
format:
  html:
    embed-resources: true
    smooth-scroll: true
    fontsize: 0.9em
    toc: true
    toc-depth: 3
    toc-title: "."
    bibliography: [references.bib]
    crossrefs-hover: false
    theme: [yeti, style.scss]
execute:
  warning: false
  message: false 
knitr:
  opts_chunk:
    out.width: "100%"
editor_options: 
  chunk_output_type: console
editor: 
  markdown: 
    wrap: 72
---

![](img/header.png)

```{r, quietly = T,verbose = F,warn.conflicts = F,logical.return = F, warning=F, echo=FALSE,message=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning=FALSE, message=FALSE)
library(knitr)
library(FactoMineR)
library(circular)
```

# INTRODUCTION

## Objectif

Nous souhaitons montrer comment le choix d'une **géométrie** va influencer la perception des proximités entre des individus qui occupent des positions à l'intérieur d'un espace. Après avoir défini des distances entre les individus dans une géométrie, nous chercherons à définir des **régions** regroupant les individus de façon à maximiser un critère d'accessibilité défini comme suit 

-   les individus situés dans une même région doivent être le plus proche possibles
-   les individus  situés dans deux régions différentes doivent être le plus éloignés possibles

Il faudra donc définir une mesure de proximité $D_{ij}$ entre les positions occupées par les individus puis choisir un critère à optimiser $H(D,R)$. Mais on pourra également travailler sur l'ensemble des positions possibles (qu'elles soient ou non occupées par un individu) et définir une partition de l'ensemble de l'espace en fonction de la proximité des positions inoccupées avec les groupes d'indvidus établis au cours de la première étape de l'analyse.

## Dispositif expérimental

On suppose que le monde est décrit par une ou plusieurs **dimensions** $D_1, D_2, D_3, ...D_k$ qui définissent des **positions** pouvant être occupées par des **individus** $i_1, ...i_n$ qui forment une **population**.

On suppose que chaque dimension comporte isolément 100 positions possibles que l'on peut noter de  de 1 à 100. Lorsque l'on croise deux dimensions le nombre de position est multiplié et non pas additionné. Un espace à 2 dimensions offrira donc 10 000 positions et  un espace à 3 dimensions 1 million de positions.

Nous nous limiterons dans notre analyse au cas des espaces à une ou deux dimensions et nous partirons systématiquement d'un même tableau de données composé de 12 individus et décrits par le tableau suivant :

```{r}
D1 <- c( 1, 17, 22, 26, 48, 52, 56, 58, 72, 76, 78, 99)
D2 <- c(48, 90,  6, 70, 31, 54, 67, 50, 18, 86, 39, 16)
code <-c("A","B","C","D","E","F","G","H","I","J","K","L")

pos<-data.frame(code,D1,D2)

kable(pos)

```

- La position D1 a été réalisée en effectuant un tirage uniforme aléatoire de 4 points entre 1 et 30, 4 points entre 41 et 60 et 4 points entre  71 et 100. Elle a donc exclu les positions $[31;40]$ et $[61 ; 70]$ du tirage au sort.

- La position D2 a été en revanche construite par un tirage aléatoire uniforme sur l'ensemble de l'intervalle $[1;100]$








# A. MONDES UNIDIMENSIONNELS

## A.1 Le monde est un segment ...

Imaginons que le monde se réduise à une ligne comme la future ville de Neom en Arabie Saoudite

![](img/neom.jpg)

### Données

On ne considère que la dimension D1 et on définit un segment de longueur 100 sur lequel se distribuent les 12 individus

```{r}
n=12
X <- D1
coo<-data.frame(X)
row.names(coo)<-c("A","B","C","D","E","F",
                "G","H","I","J","K","L")
kable(coo)
```

### Visualisation

On peut visualiser facilement le résultat en adoptant une direction quelconque puisque notre ligne n'est pas *orientée* vers une direction particulière.

```{r}
par(mfrow=c(1,1))
plot(X, rep(0,n), 
     pch=20, 
     xlab = NA,
     ylab = NA,
     xlim = c(0,100),
     ylim =c (-100,100),
     axes = F,
     main = "Le monde est un segment...")
segments(0,0,100,0, col="gray",lwd=2)
segments(0,-1,0,1, col="gray",lwd=2)
segments(100,-1,100,1, col="gray",lwd=2)
points(X, rep(0,n), 
     pch=20, 
     cex = 2, 
     col="red")
text(X, rep(0,n),row.names(coo), pos=3, cex=1)

```

### Distances

Dans notre monde linéaire on construite une distance $D_{ij}$ qui sera par définition une fonction de la seule variable de localisation $X_i$. Un choix évident est la différence en valeur absolue :

$D_{ij} = |X_i - X_j|$

Comme notre monde est *fini* on peut normaliser la distance sur l'intervalle $[0 ; 1]$ en divisant les valeurs de distance par la valeur maximale *possible* (de préférence à la valeur maximale observée).

$D_{ij}^{norm} = |X_i - X_j|/ D_{max}$

Le maximum possible étant pour nous égal ici à $D_{max} = 100$, la matrice de distance se calcule sans difficultés avec la fonction `dist()`de R-base :

```{r, echo=T}
Dij = dist(coo,diag = T, upper = T,method = "euclidean")
Dij = Dij/100
kable(as.matrix(Dij),
      caption = "Matrice de distance normalisée",
      digits=2)
```

### Partition

Dans notre espace à une dimension, la variable $X_i$ peut correspondre indifféremment à une position spatiale ou à un attribut statistique. Le choix d'une méthode de régionalisation revient donc ici à une simple classification visant à minimiser les distances intra-classes et maximiser les distances inter-classes. Il suffit donc d'appliquer un programme de classification pour obtenir une régionalisation de notre espace. On peut utiliser ici la procédure `hclust` de R-base

```{r}
reg<-hclust(Dij)
plot(reg,hang = -1,
     main = "Classification / Régionalisation",
     xlab = "Positions",
     ylab = "Distance normalisée")
```

On décide par exemple de faire 3 classes et l'on retrouve sans surprise les groupes qui avaient été favorisés dans le tirage des valeurs de la dimension D1. 

```{r}
clus<-cutree(reg,k = 3)
par(mfrow=c(1,1))
plot(X, rep(0,n), 
     pch=20, 
     xlab = NA,
     ylab = NA,
     xlim = c(0,100),
     ylim =c (-100,100),
     axes = F,
     main = "Répartition des trois classes")
segments(0,0,100,0, col="gray",lwd=2)
segments(0,-1,0,1, col="gray",lwd=2)
segments(100,-1,100,1, col="gray",lwd=2)
points(X, rep(0,n), 
     pch=20, 
     cex = 2, 
     col=clus)
text(X, rep(0,n),
     row.names(coo), 
     pos=3, 
     cex=1,
     col=clus)

```


### Densités

Plutôt que de fixer a priori le nombre de régions, on pourrait également raisonner sur la distribution des densités de points en fonction d'une fonction décroissante de la distance, ce qui permettra de repérer des pics de forte densité ("coeurs" des régions) et des bassins de faible densité ("marges" des régions).

Supposons par exemple que nous appliquions un voisinage gaussien de portée $\mu$ c'est à dire

$f(D_{ij}) = exp(- \alpha  D_{ij}^2)$ avec $\alpha = ln(0.5)/\mu^2$

```{r}
w<- seq(from = 1, to = 100, by=1)
x <-coo$X
wx<-c(w,x)
d<-dist(wx, upper = T, diag=0)
md<-as.matrix(d)
md<-md[1:100,101:112]

mu = 5
alpha = log(0.5)/(mu**2)
f <- function(D) {exp(alpha*(D**2))}
m<-apply(f(md),1,sum)/12
m <- m/mean(m) 
m5<-m



mu = 10
alpha = log(0.5)/(mu**2)
f <- function(D) {exp(alpha*(D**2))}
m<-apply(f(md),1,sum)/12
m <- m/mean(m)
m10<-m

mu = 20
alpha = log(0.5)/(mu**2)
f <- function(D) {exp(alpha*(D**2))}
m<-apply(f(md),1,sum)/12
m <- m/mean(m)
m20<-m



plot(w,m5, type="l", col="blue", 
     main = "Gaussian density (mu = 5, 10, 20)",
     ylab = "Average density",
     xlab  = "Position")
lines(w,m10, type="l", col="orange")
lines(w,m20, type="l", col="red")
abline(h=1, lty=2)
points(coo$X, rep(0.0,12),pch=20,col="black" )

```

On peut alors voir comment le nombre de pics de densité diminue lorsque la portée de la fonction de voisinage augmente et comment on passe de 5 pics ($\mu = 5$) à deux pics ($\mu = 10$) et finalement un seul ($\mu = 20$).

Ce résultat très important montre que l'on peut construire un **continuum de régionalisations** en faisant varier le paramètre $\mu$ pour une certraine famille de fonction de la distance et en examinant l'évolution de la distribution des pics et des creux d'accessibilité.

## A.2 Le monde est un cercle ...

Imaginons maintenant que le monde se réduit à une cercle autour d'une planète, comme dans le cas des anneaux de Saturne

![](img/saturne.jpg)

### Données

On transfrome les coordonnées de $D_1$ en positions angulaires sur le cercle dans le sens trigonométrique $\theta_1 ...\theta_{12}$ qui corresponde aux longitudes sur cette planète

```{r}
theta <- D1*360/100
coo<-data.frame(theta)
row.names(coo)<-c("A","B","C","D","E","F",
                "G","H","I","J","K","L")
kable(coo, caprion = "Coordonnées angulaires en degré")
```

Il s'agit apparemment de la même situation que précédemment (les valeurs de position angulaire $\theta$ mesurées en degrés correspondent aux valeurs précédentes de X) mais la géométrie n'est plus la même ce qui change fondamentalement le calcul de distances.

### Visualisation

Si l'on veut visualiser les points dans un espace à deux dimensions on peut les projeter, à la manière d'une carte du monde en projection polaire dont la longitude serait notre variable $\theta$ et la latitude une constante égale à zéro correspondant à l'équateur. Si par exemple notre monde est une planète de rayon $R$ = 1000 km, on aura 

$x_i = R \times cos(\theta_i)$

$y_i = R \times sin(\theta_i)$

```{r}
x<-cos(pi*coo$theta/180)*1000
y<-sin(pi*coo$theta/180)*1000
coo2<-data.frame(x,y)
row.names(coo2)<-row.names(coo)
kable(coo2, caption = "Coordonnées en projection polaire (R = 1000 km)")


```


Mais en réalité il est inutile d'introduire une projection dans un espace à deux dimensions si l'on supposer que les relations ne peuvent se faire qu'en circulant le long du cercle. La visualisation correcte de ce monde n'a donc pas besoin d'une échelle de distance mais plutôt d'une échelle angulaire. 

```{r}

par(mar = c(0,0,3,0))
plot(coo2 ,  
     asp=1,
     ylim= c(-1050, 1050),
     xlim = c(-1050,1050),
     axes = F,
     xlab=NA,
     ylab=NA,
      pch=20,
     col="red",
     cex=0,
     main = "Le monde est un cercle ...")

z<-seq(-pi, pi+0.1, 0.1)
zx<-cos(z)*1000
zy<-sin(z)*1000
lines(cbind(zx,zy),col="gray",lwd=2)

points(coo2 ,  
      pch=20,
       col="red",
       cex=2)


text(coo2,
     row.names(coo2),
     pos=3,
     cex=1,
     col="black")


```

Le changement de géométrie entraîne un rapprochement spectaculaire des points $A$ et $L$ qui étaient auparavant les deux points les plus éloignés dans le monde linéaire.


### Distances

Dans notre monde circulaire, il n'est pas possible de se déplacer en ligne droite. Les distances correspondent donc aux trajets effectués surun arc de cercle ce qui donne une valeur maximale égale à $\pi \times R$ avec $R$ égal au rayon du cercle. On normalise par la distance maximale qui est égale à $\pi R$ soit 3141.5 km dans notre exemple. 

::: {.callout-note title="Le package circular" collapse="true"}
Le calcul des distances angulaires est très facile avec le package [circular](https://www.rdocumentation.org/packages/circular/versions/0.5-1).

Celui-ci comporte par ailleurs de très nombreuses fonctions d'analyse statistique appliqués à cette géométrie particulière du cercle @lund2004, @jammalamadaka2001
:::

```{r}
library(circular)
C<-circular(theta, type="angles",units="degrees",names = row.names(coo))
  D<-dist.circular(C,diag = T, upper=T,method ="geodesic")
  D<-D/pi
  MD<-as.matrix(D)
  row.names(MD)<-row.names(coo)
  colnames(MD)<-row.names(coo)
kable(as.matrix(MD), caption = "Distance circulaire normalisée", digits=2)
```

La distance maximale est alors observée entre des points situés à l'opposé l'un de l'autre sur le cercle comme A et D. Mais en revanche les points qui étaient auparavant très éloignés dans le monde du segment comme A et L sont désormais très proches dans le monde du cercle puisque celui-ci se referme à leur niveau.

### Partition

Dans notre monde circulaire, la classification est très différente de celle observée dans le monde du segment alors même que les valeurs numériques sont au départ les mêmes. C'est la projection qui diffère.

```{r}


reg<-hclust(D)
plot(reg,hang = -1,
     main = "Classification / Régionalisation",
     xlab = "Positions",
     ylab = "Distance normalisée")
```

On va retenir ici 4 classes

```{r}
clus<-cutree(reg,k = 4)
z<-seq(-pi, pi+0.1, 0.1)
zx<-cos(z)*1000
zy<-sin(z)*1000

par(mar = c(0,0,3,0))
plot(coo2 ,  
     asp=1,
     ylim= c(-1050, 1050),
     xlim = c(-1050,1050),
     axes = F,
     xlab=NA,
     ylab=NA,
      pch=20,
     col="red",
     cex=0,
     main = "Le monde est un cercle ...")


lines(cbind(zx,zy),col="gray",lwd=2)

points(coo2 ,  
      pch=20,
       col=clus,
       cex=2)

text(coo2,
     row.names(coo2),
     pos=3,
     cex=1,
     col=clus)

```

### Densités

Comme dans le cas du monde linéaire, on peut tracer des courbes de densité paramétriques pour repérer les coeurs et les marges de notre espace. On utilise ici la méthode de lissage par kernel paramétrique (vonmises) du package `circular`avec des paramètres kappa de valeur 9 , 18 et 36.

```{r}
res9 <- density(C, bw=10, control.circular=list(units="degrees"))
res18 <- density(C, bw=20, control.circular=list(units="degrees"))
res36 <- density(C, bw=40, adjust=2, control.circular=list(units="degrees"))
par(mar=c(0,0,3,0))
plot(C,xlim = c(-1.1,1.1),ylim=c(-1.1,1.1),
     main = "Kernel density (kappa = 9, 18, 36)")
lines(res9, offset=0.85, col="red")
lines(res18, offset=0.85, col="orange")
lines(res36, offset=0.85, col="blue")

```

On retouve la même méthode de calcul des densités que dans le monde linéaire, mais appliqué aux coordonnées angulaires. Mais avec une différence importante qui est ici la permanence de l'existence de 4 pics de densité aux différentes échelles de généralisation. 


# B. MONDES BIDIMENSIONNELS

## B.1 Le monde est un échiquier

![](img/chessboard.jpg)

L'image la plus simple qui vienne à l'esprit lorsque l'on évoque un monde **fini** à deux dimensions est celle d'un échuiquier ou d'un damier. Comme nous avons introduit l'hypothèse que chaque individu occupait une position et que deux individus ne pouvaient pas occuper la même position, on peut définit des **cases** ou **carreaux** correspondant aux différentes positions autorisées. Le faite que ces carreaux soient de forme carrée n'est évidemment pas obligatoire (on aurait pu choisir des triangles ou des hexagone pour produire un pavage de l'espace) mais cela est suffisant dans un premier temps pour formuler quelques hypothèses sur les distances à l'intérieur de ce monde et cela permet de retrouver un certain nombre de métriques théoriques (euclidienne, Manhattan, Chebyshev, ...) pour définir les distances entre les individus.

### Données

On reprend telle quelle les données de position des dimensions D1 et D2 en soustrayant juste la valeur de 0.5 pour placer nos individus au centre des cases d'un échiquier formant un carré de dimension 100 x 100 avec un reprère orthonormé placé au point (0,0). 

```{r}
n=12
X <- D1-0.5
Y <- D2-0.5
coo<-data.frame(X,Y)
row.names(coo)<-c("A","B","C","D","E","F",
                "G","H","I","J","K","L")
kable(coo)
```


### Visualisation

La visualisation est immédiate et facile, tous les logiciels de cartographie ou de statistique étant habitué à cette géométrie

```{r}

par(mar = c(3,3,3,3))
plot(coo ,  
     asp=1,
     ylim= c(0, 100),
     xlim = c(0,100),
     axes=T,
     xlab=T,
     ylab=T,
     cex=0,
     main = "Le monde est un échiquier ...")

polygon(x=c(0,100,100,0), y=c(0,0,100,100),col="lightyellow")


points(coo , 
      pch=15,
       col="red",
       cex=0.9)


text(coo,
     row.names(coo),
     pos=3,
     cex=1,
     col="black")


```





## B.2 Le monde est un disque

![](img/discworld.jpg)

L'idée que le Monde soit un disque est une idée ancienne et même si la science a fini par l'infirmer elle demeure sans nul doute présente dans beaucoup de représentations contemporaines, propagées notamment par les théories du complot sur Youtube [@mohammed2019]. Il semble aussi que la conception d'une Terre plate soit une étape dans le dévloppement cognitif des enfants [@vaiopoulou2018]. Enfin, beaucoup de romans, notamment de science fiction ont utiliséce modèle pour construire des univers imaginaires, le plus célèbre étant sans doute celui des *Annales du Disque Monde* et la création annexe par l'auteur d'une série d'ouvrages portant sur la *Science of Discworld* [@stewart2011] .

> "*The Disc, as it’s referred to in the novel, is quite literally a disc. The flat planet is carefully balanced on the backs of four elephants – Berilia, Tubul, Great T’Phon, and Jerakeen – who in turn stand on the Star Turtle, the Great A’Tuin, as it swims through space. [...]  Since the Disc is flat, there are no cardinal directions. Instead, the four directions are Hubwards (towards the Hub), Rimwards (towards the Rim), Turnwise (the direction that the Disc rotates in), and Widdershins (opposite to Turnwise). This leads to an endless onslaught of puns and geographical jokes. At the end of the book we discover the Circumfence, the rope fence that lines the edge of the Disc to help ensure no one falls off. There’s also the beauty of the Counterweight Continent – a land fabled to be made out of pure gold that exists to keep the Disc from tipping over. Everything we learn about the geography of Discworld is strangely cohesive while being entirely silly.* "
Source : [Fernandez W., The Color of Magic, Consulté le 21/11/2024](https://wendyfernandez.net/2022/06/14/the-color-of-magic-an-introduction-to-sir-terry-pratchetts-discworld/)

Dans la perspective d'abstraction qui est la nôtre, un monde fini en forme de disque constitue un cas particulièrement intéressant puisque les positions peuvent y être mesurées par un jeu de coordonnées à la fois métrique et angulaire, ce qui revient en pratique à combiner les deux mondes vus précédemment : segment et cercle. 

### Données

On reprend les positions angulaires $\theta_1 ...\theta_{12}$ issues de la variable D1 et on ajoute 12 coordonnées de rayon $\rho_1 ...\rho_{12}$ qui mesurent la distance au centre. On fixe la distance maximale au centre à 1

```{r}
n=12
theta <- D1 *360/100
rho <- D2/100
coo<-data.frame(theta,rho)
row.names(coo)<-c("A","B","C","D","E","F",
                "G","H","I","J","K","L")
kable(coo)
```

### Visualisation

On peut propooser une visualisation planaire en projetant les coordonnées dans un espace euclidien à l'aide des formules de transformation des coordonnées polaires précédentes : 

$x_i = \rho_i \times cos(\theta_i)$

$y_i = \rho_i \times sin(\theta_i)$

```{r}
coo$Xi<-coo$rho*cos(pi*coo$theta/180)
coo$Yi<-coo$rho*sin(pi*coo$theta/180)
z<-seq(-pi, pi+0.1, 0.1)
zx<-cos(z)
zy<-sin(z)

par(mar = c(0,0,3,0), mfrow=c(1,1))
plot(coo$Xi,coo$Yi,   
     asp=1,
     ylim= c(-1, 1),
     xlim = c(-1,1),
     axes = F,
     xlab=NA,
     ylab=NA,
     
     main = "Le monde est un disque ...")
polygon(cbind(zx,zy),col="lightyellow")
points(coo$Xi, coo$Yi,
     pch=20,
     col="red",
     cex=2)
text(coo$Xi, coo$Yi,
     row.names(coo),
     pos=3,
     cex=0.8,
     col="black")
points(0,0, pch=3)


```

Mais en réalité, la propriété fondamentale d'un monde de ce type est qu'il n'existe pas de direction privilégiée de type "Nord", "Sud", "Est" ou "Ouest". Il y a en revanche un centre et une périphérie (définis par la position sur la coordonnée sur $\rho$) et une direction de rotation qui suit le sens trignométrique (valeurs croissantes de $\theta$) ou le sens des aiguilles d'une montre (valeurs décroissantes de $\theta$)

### Distances

Dans le monde du disque il existe de très nombreuses possibilités de mesurer les distances, conduisant chacune à des formes différentes de regroupement des points en fonction de leur proximité. D'une manière générale on peut écrire :

$D_{ij} = f(\rho_i, \theta_i, \rho_j, \theta_j)$

On peut par exemple imaginer une décomposition additive de la fontion $f$ en deux fonctions $f_1, f_2, f_3$ telles que  : 

$D_{ij}  = f_1(\rho_i,\rho_j) + f_2(\theta_i, \theta_j)$

On retrouve ainsi deux fonctions de distances classiques utilisées en géographie urbaine : la distance périphérique, la distance radiale:  

La **distance radiale ** fait l'hypothèse que tous les déplacements doivent passer par le centre du disque en suivant les radiales. Ce qui donne :

$D_{ij}^{Rad}  = \rho_i + \rho_j$


La **distance périphérique** fait l'hypothèse que tous les déplacements dovent passer par la bordure externe du disque car le centre est saturé.

$D_{ij}^{Cir}  = (R - \rho_i)+ (R- \rho_j) + 2 \pi R \frac{|\theta_i-\theta_j|}{360}$



```{r}
cooex<-coo[c(1,4),]
cooex$Xi<-cooex$rho*cos(pi*cooex$theta/180)
cooex$Yi<-cooex$rho*sin(pi*cooex$theta/180)
z<-seq(-pi, pi+0.1, 0.1)
zx<-cos(z)
zy<-sin(z)

## Radiale
par(mar = c(0,0,3,0), mfrow=c(1,2))
plot(cooex$Xi,cooex$Yi,   
     asp=1,
     ylim= c(-1, 1),
     xlim = c(-1,1),
     axes = F,
     xlab=NA,
     ylab=NA,
     
     main = "Distance radiale")
polygon(cbind(zx,zy),col="lightyellow")
points(cooex$Xi, cooex$Yi,
     pch=20,
     col="red",
     cex=2)
text(cooex$Xi, cooex$Yi,
     row.names(cooex),
     pos=3,
     cex=0.8,
     col="black")
points(0,0, pch=3)

segments(cooex$Xi[1],cooex$Yi[1],0,0,col='blue', lwd=2)
segments(cooex$Xi[2],cooex$Yi[2],0,0,col='blue',lwd=2)

## Périphérique
plot(cooex$Xi,cooex$Yi,   
     asp=1,
     ylim= c(-1, 1),
     xlim = c(-1,1),
     axes = F,
     xlab=NA,
     ylab=NA,
     
     main = "Distance périphériqu")
polygon(cbind(zx,zy),col="lightyellow")
points(cooex$Xi, cooex$Yi,
     pch=20,
     col="red",
     cex=2)
text(cooex$Xi, cooex$Yi,
     row.names(cooex),
     pos=3,
     cex=0.8,
     col="black")
points(0,0, pch=3)

cooex$XR<-cos(pi*cooex$theta/180)
cooex$YR<-sin(pi*cooex$theta/180)

segments(cooex$Xi[1],cooex$Yi[1],cooex$XR[1],cooex$YR[1],col='red', lwd=2)
segments(cooex$Xi[2],cooex$Yi[2],cooex$XR[2],cooex$YR[2],col='red', lwd=2)
min<-cooex$theta[1]
max<-cooex$theta[2]
z<-seq(min, max, 0.1)
zx<-cos(pi*z/180)
zy<-sin(pi*z/180)
lines(cbind(zx,zy),col="red",lwd=2)


```


La **distance circumradiale** correspond enfin au minimum de la distance radiale et de la distance périphérique, c'est à dire au choix du meilleur itinéraire entre deux options de passage soit par le centre, soit par la périphérie. 

Essayons de la calculer pour voir à quelle matrice de distance elle aboutit.

```{r}
mat<-matrix(,nrow=12,ncol=12)

## Distance radiale
Drad<-mat  
for(i in 1:12){
  for(j in 1:12){
    Drad[i,j]<-rho[i]+rho[j]
  }
}

## Distance périphérique
Dper<-mat 
for(i in 1:12){
  for(j in 1:12){
    Dper[i,j]<- (1-rho[i]) + 
                (1-rho[j]) + 
                 2*pi*abs(theta[i]-theta[j])/360
  }
}


## Distance circumradiale
Dcirc<-mat
for(i in 1:12){
  for(j in 1:12){
    Dcirc[i,j]<- min(Dper[i,j],Drad[i,j])
  }
}


row.names(Dcirc)<-row.names(coo)
colnames(Dcirc)<-row.names(coo)

kable(Dcirc/2, caption = "Distance circumradiale", digits=2)

```


### Partition

```{r}

par(mfrow=c(1,1))
reg<-hclust(D)
plot(reg,hang = -1,
     labels = row.names(coo),
     main = "Classification en distance circumradiale",
     xlab = "Positions",
     ylab = "Distance circum radiale normalisée")
```

L'arbre nous suggère 4 classes que l'on peut visualiser ainsi

```{r}
clus<-cutree(reg,k=4)

z<-seq(-pi, pi+0.1, 0.1)
zx<-cos(z)
zy<-sin(z)

par(mar = c(0,0,3,0), mfrow=c(1,1))
plot(coo$Xi,coo$Yi,   
     asp=1,
     ylim= c(-1, 1),
     xlim = c(-1,1),
     axes = F,
     xlab=NA,
     ylab=NA,
     
     main = "Le monde est un disque ...")
polygon(cbind(zx,zy),col="lightyellow")
points(coo$Xi, coo$Yi,
     pch=20,
     col=clus,
     cex=2)
text(coo$Xi, coo$Yi,
     row.names(coo),
     pos=3,
     cex=0.8,
     col=clus)
points(0,0, pch=3)

```

L'image obtenu est de prime abord assez perturbante puisque des points qui nous semblent proches (en distance euclidienne) se retouvent en fait séparés dans des classes différentes et des points apparemment éloignés sont regroupés. La difficulté vient du fait que notre oeil regroupe de façon euclidienne alors que la distance qui est ici à l'oeuvre (circumradiale) opère différemment. Elle conduit en particulier à rapprocher les points localisés dans un même secteur angulaire c'est-à-dire ayant des valeurs proches de $\theta$.

### Densité

Le calcul des densités avec cette géométrie pour différentes portées de lissage est assez complexe ,









## B.3 Le monde est un triangle 

## B.4 Le monde est un donuts

## B.5 Le monde est une sphère


# C. MONDES RETICULAIRES

## D.1 Le monde est un graphe planaire

## D.1 Le monde est un graphe non planaire

# ANNEXES

## Bibliographie
