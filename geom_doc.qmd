---
title: "Géometries de mondes abstraits"
subtitle: "Régionalisation d'un semis de population en fonction d'une distance"
date: "2024-11-18"
date-format: iso
author: "Claude Grasland"
lang: fr
format:
  html:
    embed-resources: true
    smooth-scroll: true
    fontsize: 0.9em
    toc: true
    toc-depth: 3
    toc-title: "."
    bibliography: [references.bib]
    crossrefs-hover: false
    theme: [yeti, style.scss]
execute:
  warning: false
  message: false 
knitr:
  opts_chunk:
    out.width: "100%"
editor_options: 
  chunk_output_type: console
editor: 
  markdown: 
    wrap: 72
---

![](img/header.png)

```{r, quietly = T,verbose = F,warn.conflicts = F,logical.return = F, warning=F, echo=FALSE,message=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning=FALSE, message=FALSE)
library(knitr)
library(FactoMineR)
library(circular)
library(MASS)
library(potential)
library(mapsf)
library(sf)
library(Ternary)
library(RColorBrewer)
library(ClusTorus)

```

# INTRODUCTION

## Objectif

Nous souhaitons montrer comment le choix d'une **géométrie** va influencer la perception des proximités entre des individus qui occupent des positions à l'intérieur d'un espace. Après avoir défini des distances entre les individus dans une géométrie, nous chercherons à définir des **régions** regroupant les individus de façon à maximiser un critère d'accessibilité défini comme suit 

-   les individus situés dans une même région doivent être le plus proche possibles
-   les individus  situés dans deux régions différentes doivent être le plus éloignés possibles

Il faudra donc définir une mesure de proximité $D_{ij}$ entre les positions occupées par les individus puis choisir un critère à optimiser $H(D,R)$. Mais on pourra également travailler sur l'ensemble des positions possibles (qu'elles soient ou non occupées par un individu) et définir une partition de l'ensemble de l'espace en fonction de la proximité des positions inoccupées avec les groupes d'indvidus établis au cours de la première étape de l'analyse.

## Dispositif expérimental

On suppose que le monde est décrit par une ou plusieurs **dimensions** $D_1, D_2, D_3, ...D_k$ qui définissent des **positions** pouvant être occupées par des **individus** $i_1, ...i_n$ qui forment une **population**.

On suppose que chaque dimension comporte isolément 100 positions possibles que l'on peut noter de  de 1 à 100. Lorsque l'on croise deux dimensions le nombre de position est multiplié et non pas additionné. Un espace à 2 dimensions offrira donc 10 000 positions et  un espace à 3 dimensions 1 million de positions.

Nous nous limiterons dans notre analyse au cas des espaces à une ou deux dimensions et nous partirons systématiquement d'un même tableau de données composé de 12 individus et décrits par le tableau suivant :

```{r}
D1 <- c( 1, 17, 22, 26, 48, 52, 56, 58, 72, 76, 78, 99)
D2 <- c(48, 90,  6, 70, 31, 54, 67, 50, 18, 86, 39, 16)
#D3 <- c(28, 78, 40, 87, 93,  5, 52, 88, 55, 45, 95, 45)

code <-c("A","B","C","D","E","F","G","H","I","J","K","L")

pos<-data.frame(code,D1,D2)

kable(pos)

```

- La position D1 a été réalisée en effectuant un tirage uniforme aléatoire de 4 points entre 1 et 30, 4 points entre 41 et 60 et 4 points entre  71 et 100. Elle a donc exclu les positions $[31;40]$ et $[61 ; 70]$ du tirage au sort.

- Les positions D2 a été en revanche construites par un tirage aléatoire uniforme sur l'ensemble de l'intervalle $[1;100]$








# A. MONDES UNIDIMENSIONNELS

## A.1 Le monde est un segment ...

Imaginons que le monde se réduise à une ligne comme la future ville de Neom en Arabie Saoudite

![](img/neom.jpg)

### Données

On ne considère que la dimension D1 et on définit un segment de longueur 100 sur lequel se distribuent les 12 individus

```{r}
n=12
X <- D1
coo<-data.frame(X)
row.names(coo)<-c("A","B","C","D","E","F",
                "G","H","I","J","K","L")
kable(coo)
```

### Visualisation

On peut visualiser facilement le résultat en adoptant une direction quelconque puisque notre ligne n'est pas *orientée* vers une direction particulière.

```{r}
par(mfrow=c(1,1))
plot(X, rep(0,n), 
     pch=20, 
     xlab = NA,
     ylab = NA,
     xlim = c(0,100),
     ylim =c (-100,100),
     axes = F,
     main = "Le monde est un segment...")
segments(0,0,100,0, col="gray",lwd=2)
segments(0,-1,0,1, col="gray",lwd=2)
segments(100,-1,100,1, col="gray",lwd=2)
points(X, rep(0,n), 
     pch=20, 
     cex = 2, 
     col="red")
text(X, rep(0,n),row.names(coo), pos=3, cex=1)

```

### Distances

Dans notre monde linéaire on construite une distance $D_{ij}$ qui sera par définition une fonction de la seule variable de localisation $X_i$. Un choix évident est la différence en valeur absolue :

$D_{ij} = |X_i - X_j|$

Comme notre monde est *fini* on peut normaliser la distance sur l'intervalle $[0 ; 1]$ en divisant les valeurs de distance par la valeur maximale *possible* (de préférence à la valeur maximale observée).

$D_{ij}^{norm} = |X_i - X_j|/ D_{max}$

Le maximum possible étant pour nous égal ici à $D_{max} = 100$, la matrice de distance se calcule sans difficultés avec la fonction `dist()`de R-base :

```{r, echo=T}
Dij = dist(coo,diag = T, upper = T,method = "euclidean")
Dij = Dij/100
kable(as.matrix(Dij),
      caption = "Matrice de distance normalisée",
      digits=2)
```

### Partition

Dans notre espace à une dimension, la variable $X_i$ peut correspondre indifféremment à une position spatiale ou à un attribut statistique. Le choix d'une méthode de régionalisation revient donc ici à une simple classification visant à minimiser les distances intra-classes et maximiser les distances inter-classes. Il suffit donc d'appliquer un programme de classification pour obtenir une régionalisation de notre espace. On peut utiliser ici la procédure `hclust` de R-base

```{r}
reg<-hclust(Dij)
plot(reg,hang = -1,
     main = "Classification / Régionalisation",
     xlab = "Positions",
     ylab = "Distance normalisée")
```

On décide par exemple de faire 3 classes et l'on retrouve sans surprise les groupes qui avaient été favorisés dans le tirage des valeurs de la dimension D1. 

```{r}
clus<-cutree(reg,k = 3)
par(mfrow=c(1,1))
plot(X, rep(0,n), 
     pch=20, 
     xlab = NA,
     ylab = NA,
     xlim = c(0,100),
     ylim =c (-100,100),
     axes = F,
     main = "Régions du monde segmentaire")
segments(0,0,100,0, col="gray",lwd=2)
segments(0,-1,0,1, col="gray",lwd=2)
segments(100,-1,100,1, col="gray",lwd=2)
points(X, rep(0,n), 
     pch=20, 
     cex = 2, 
     col=clus)
text(X, rep(0,n),
     row.names(coo), 
     pos=3, 
     cex=1,
     col=clus)

```


### Densités

Plutôt que de fixer a priori le nombre de régions, on pourrait également raisonner sur la distribution des densités de points en fonction d'une fonction décroissante de la distance, ce qui permettra de repérer des pics de forte densité ("coeurs" des régions) et des bassins de faible densité ("marges" des régions).

Supposons par exemple que nous appliquions un voisinage gaussien de portée $\mu$ c'est à dire

$f(D_{ij}) = exp(- \alpha  D_{ij}^2)$ avec $\alpha = ln(0.5)/\mu^2$

```{r}
w<- seq(from = 1, to = 100, by=1)
x <-coo$X
wx<-c(w,x)
d<-dist(wx, upper = T, diag=0)
md<-as.matrix(d)
md<-md[1:100,101:112]

mu = 5
alpha = log(0.5)/(mu**2)
f <- function(D) {exp(alpha*(D**2))}
m<-apply(f(md),1,sum)/12
m <- m/mean(m) 
m5<-m



mu = 10
alpha = log(0.5)/(mu**2)
f <- function(D) {exp(alpha*(D**2))}
m<-apply(f(md),1,sum)/12
m <- m/mean(m)
m10<-m

mu = 20
alpha = log(0.5)/(mu**2)
f <- function(D) {exp(alpha*(D**2))}
m<-apply(f(md),1,sum)/12
m <- m/mean(m)
m20<-m



plot(w,m5, type="l", col="blue", 
     main = "Gaussian density (mu = 5, 10, 20)",
     ylab = "Average density",
     xlab  = "Position")
lines(w,m10, type="l", col="orange")
lines(w,m20, type="l", col="red")
abline(h=1, lty=2)
points(coo$X, rep(0.0,12),pch=20,col="black" )

```

On peut alors voir comment le nombre de pics de densité diminue lorsque la portée de la fonction de voisinage augmente et comment on passe de 5 pics ($\mu = 5$) à deux pics ($\mu = 10$) et finalement un seul ($\mu = 20$).

Ce résultat très important montre que l'on peut construire un **continuum de régionalisations** en faisant varier le paramètre $\mu$ pour une certraine famille de fonction de la distance et en examinant l'évolution de la distribution des pics et des creux d'accessibilité.

## A.2 Le monde est un cercle ...

Imaginons maintenant que le monde se réduit à une cercle autour d'une planète, comme dans le cas des anneaux de Saturne

![](img/saturne.jpg)

### Données

On transfrome les coordonnées de $D_1$ en positions angulaires sur le cercle dans le sens trigonométrique $\theta_1 ...\theta_{12}$ qui corresponde aux longitudes sur cette planète

```{r}
theta <- D1*360/100
coo<-data.frame(theta)
row.names(coo)<-c("A","B","C","D","E","F",
                "G","H","I","J","K","L")
kable(coo, caprion = "Coordonnées angulaires en degré")
```

Il s'agit apparemment de la même situation que précédemment (les valeurs de position angulaire $\theta$ mesurées en degrés correspondent aux valeurs précédentes de X) mais la géométrie n'est plus la même ce qui change fondamentalement le calcul de distances.

### Visualisation

Si l'on veut visualiser les points dans un espace à deux dimensions on peut les projeter, à la manière d'une carte du monde en projection polaire dont la longitude serait notre variable $\theta$ et la latitude une constante égale à zéro correspondant à l'équateur. Si par exemple notre monde est une planète de rayon $R$ = 1000 km, on aura 

$x_i = R \times cos(\theta_i)$

$y_i = R \times sin(\theta_i)$

```{r}
x<-cos(pi*coo$theta/180)*1000
y<-sin(pi*coo$theta/180)*1000
coo2<-data.frame(x,y)
row.names(coo2)<-row.names(coo)
kable(coo2, caption = "Coordonnées en projection polaire (R = 1000 km)")


```


Mais en réalité il est inutile d'introduire une projection dans un espace à deux dimensions si l'on supposer que les relations ne peuvent se faire qu'en circulant le long du cercle. La visualisation correcte de ce monde n'a donc pas besoin d'une échelle de distance mais plutôt d'une échelle angulaire. 

```{r}

par(mar = c(0,0,3,0))
plot(coo2 ,  
     asp=1,
     ylim= c(-1050, 1050),
     xlim = c(-1050,1050),
     axes = F,
     xlab=NA,
     ylab=NA,
      pch=20,
     col="red",
     cex=0,
     main = "Le monde est un cercle ...")

z<-seq(-pi, pi+0.1, 0.1)
zx<-cos(z)*1000
zy<-sin(z)*1000
lines(cbind(zx,zy),col="gray",lwd=2)

points(coo2 ,  
      pch=20,
       col="red",
       cex=2)


text(coo2,
     row.names(coo2),
     pos=3,
     cex=1,
     col="black")


```

Le changement de géométrie entraîne un rapprochement spectaculaire des points $A$ et $L$ qui étaient auparavant les deux points les plus éloignés dans le monde linéaire.


### Distances

Dans notre monde circulaire, il n'est pas possible de se déplacer en ligne droite. Les distances correspondent donc aux trajets effectués surun arc de cercle ce qui donne une valeur maximale égale à $\pi \times R$ avec $R$ égal au rayon du cercle. On normalise par la distance maximale qui est égale à $\pi R$ soit 3141.5 km dans notre exemple. 

::: {.callout-note title="Le package circular" collapse="true"}
Le calcul des distances angulaires est très facile avec le package [circular](https://www.rdocumentation.org/packages/circular/versions/0.5-1).

Celui-ci comporte par ailleurs de très nombreuses fonctions d'analyse statistique appliqués à cette géométrie particulière du cercle @lund2004, @jammalamadaka2001
:::

```{r}
library(circular)
C<-circular(theta, type="angles",units="degrees",names = row.names(coo))
  D<-dist.circular(C,diag = T, upper=T,method ="geodesic")
  D<-D/pi
  MD<-as.matrix(D)
  row.names(MD)<-row.names(coo)
  colnames(MD)<-row.names(coo)
kable(as.matrix(MD), caption = "Distance circulaire normalisée", digits=2)
```

La distance maximale est alors observée entre des points situés à l'opposé l'un de l'autre sur le cercle comme A et D. Mais en revanche les points qui étaient auparavant très éloignés dans le monde du segment comme A et L sont désormais très proches dans le monde du cercle puisque celui-ci se referme à leur niveau.

### Partition

Dans notre monde circulaire, la classification est très différente de celle observée dans le monde du segment alors même que les valeurs numériques sont au départ les mêmes. C'est la projection qui diffère.

```{r}


reg<-hclust(D)
plot(reg,hang = -1,
     main = "Classification / Régionalisation",
     xlab = "Positions",
     ylab = "Distance normalisée")
```

On va retenir ici 4 classes

```{r}
clus<-cutree(reg,k = 4)
z<-seq(-pi, pi+0.1, 0.1)
zx<-cos(z)*1000
zy<-sin(z)*1000

par(mar = c(0,0,3,0))
plot(coo2 ,  
     asp=1,
     ylim= c(-1050, 1050),
     xlim = c(-1050,1050),
     axes = F,
     xlab=NA,
     ylab=NA,
      pch=20,
     col="red",
     cex=0,
     main = "Régions du monde circulaire")


lines(cbind(zx,zy),col="gray",lwd=2)

points(coo2 ,  
      pch=20,
       col=clus,
       cex=2)

text(coo2,
     row.names(coo2),
     pos=3,
     cex=1,
     col=clus)

```

### Densités

Comme dans le cas du monde linéaire, on peut tracer des courbes de densité paramétriques pour repérer les coeurs et les marges de notre espace. On doit alors faire apport à des lois de probabilité définies sur le cercle comme la loi de von Mises.

::: {.callout-note title="La distribution de von Mises" collapse="true"}

Vu notre faible niveau en mathématique, on s'appuiera ici sur l'article Wikipedia consécré à la loi de von Mises, disponible en cinq langues seulement dont le [français](https://fr.wikipedia.org/wiki/Loi_de_von_Mises) et l'[anglais](https://en.wikipedia.org/wiki/Von_Mises_distribution).

>Dans la théorie des probabilités et en statistiques, la loi (distribution) de von Mises (appelée également distribution normale circulaire ou distribution de Tikhonov) est une densité de probabilité continue, nommée d'après Richard von Mises. Elle donne une bonne approximation de la loi normale périodique (en), qui est l'analogue circulaire de la loi normale. Un angle de diffusion $θ$ parcourant un cercle est une variable aléatoire suivant la loi normale périodique avec une variance non périodique qui croît linéairement en temps. D'un autre côté, la loi de von Mises est la distribution stationnaire d'un processus de diffusion et déviation sur le cercle dans un potentiel harmonique, i.e. avec une orientation guidée.La loi de von Mises est la loi de probabilités à entropie maximale pour une valeur donnée de $z = e^{i\theta}$. La loi de von Mises est un cas particulier de la loi de von Mises-Fisher sur la N-sphère. [Source : Wikipedia France, consulté le 27 nov. 2024](https://fr.wikipedia.org/wiki/Loi_de_von_Mises)

![Densité de probabilité de la loi de von Mises](img/VonMises_distribution.png){width=300}


:::
On utilise ici la méthode de lissage par kernel paramétrique (vonmises) du package `circular`avec des paramètres kappa de valeur 9 , 18 et 36.

```{r}
res9 <- density(C, bw=10, control.circular=list(units="degrees"))
res18 <- density(C, bw=20, control.circular=list(units="degrees"))
res36 <- density(C, bw=40, adjust=2, control.circular=list(units="degrees"))
par(mar=c(0,0,3,0))
plot(C,xlim = c(-1.1,1.1),ylim=c(-1.1,1.1),
     main = "Kernel density (kappa = 9, 18, 36)")
lines(res9, offset=0.85, col="red")
lines(res18, offset=0.85, col="orange")
lines(res36, offset=0.85, col="blue")

```

On retouve la même méthode de calcul des densités que dans le monde linéaire, mais appliqué aux coordonnées angulaires. Mais avec une différence importante qui est ici la permanence de l'existence de 4 pics de densité aux différentes échelles de généralisation. 


# B. MONDES BIDIMENSIONNELS

## B.1 Le monde est un échiquier

![](img/chessboard.jpg)

L'image la plus simple qui vienne à l'esprit lorsque l'on évoque un monde **fini** à deux dimensions est celle d'un échuiquier ou d'un damier. Comme nous avons introduit l'hypothèse que chaque individu occupait une position et que deux individus ne pouvaient pas occuper la même position, on peut définit des **cases** ou **carreaux** correspondant aux différentes positions autorisées. Le faite que ces carreaux soient de forme carrée n'est évidemment pas obligatoire (on aurait pu choisir des triangles ou des hexagone pour produire un pavage de l'espace) mais cela est suffisant dans un premier temps pour formuler quelques hypothèses sur les distances à l'intérieur de ce monde et cela permet de retrouver un certain nombre de métriques théoriques (euclidienne, Manhattan, Chebyshev, ...) pour définir les distances entre les individus.

### Données

On reprend telle quelle les données de position des dimensions D1 et D2 en soustrayant juste la valeur de 0.5 pour placer nos individus au centre des cases d'un échiquier formant un carré de dimension 100 x 100 avec un reprère orthonormé placé au point (0,0). 

```{r}
n=12
X <- D1-0.5
Y <- D2-0.5
coo<-data.frame(X,Y)
row.names(coo)<-c("A","B","C","D","E","F",
                "G","H","I","J","K","L")
kable(coo)
```


### Visualisation

La visualisation est immédiate et facile, tous les logiciels de cartographie ou de statistique étant habitué à cette géométrie

```{r}

par(mar = c(3,3,3,3))
plot(coo ,  
     asp=1,
     ylim= c(0, 100),
     xlim = c(0,100),
     axes=T,
     xlab=T,
     ylab=T,
     cex=0,
     main = "Le monde est un échiquier ...")

polygon(x=c(0,100,100,0), y=c(0,0,100,100),col="lightyellow")


points(coo , 
      pch=15,
       col="red",
       cex=0.9)


text(coo,
     row.names(coo),
     pos=3,
     cex=1,
     col="black")


```


### Distance

Un grand nombre de métriques sont adaptées à cette géométrie. On peut notamment utiliser la famille des distances de Minkowski qui est uneformule générale de calcul des distance entre deux points dans l’espace dimensionnel n, applicable au cas de l'espace de dimension 2 qui nous intéresse ici. Elle est une généralisation des distances Euclidienne, de Manhattan et de Tchebychev. Dans un espace de dimension n, la distance de Minkowski de paramètre ${\lambda}$ s'écrira :

$D^{Mink}(a,b) = \sqrt[\lambda]{\sum^n_{i=1}{(|a_i-b_i|)^\lambda})}$


Le paramètre $\lambda$ est l’ordre de la métrique de Minkowski. Pour différentes valeurs de $\lambda$, la distance peut être calculée d'au moins  trois manières différentes :

- $\lambda = 1$ : Distance de Manhattan (métrique $L^1$)

- $\lambda = 2$ : Distance Euclidienne (métrique $L^2$)

- $\lambda = \infty$ : Distance de Tchebychev (métrique $L^\infty$)


Si l'on retient par exemple la distance euclidienne et si on normalise par la plus grande distance possible ($100\sqrt2$) qui correspond à la distance entre deux points opposés du carré on obtient la matrice de distance suivante :

```{r}
Dij = dist(coo,diag = T, upper = T,method = "euclidean")
Dij = Dij/(100*sqrt(2))
kable(as.matrix(Dij),
      caption = "Matrice de distance normalisée",
      digits=2)
```


### Partition

On applique comme précédemment un programme de classification sur la matrice de distancepour obtenir une régionalisation de notre espace. 

```{r}
reg<-hclust(Dij)
plot(reg,hang = -1,
     main = "Classification / Régionalisation",
     xlab = "Positions",
     ylab = "Distance normalisée")
```

On décide par exemple de faire 4 classes :

```{r}
clus<-cutree(reg,k = 4)
par(mar = c(3,3,3,3))
plot(coo ,  
     asp=1,
     ylim= c(0, 100),
     xlim = c(0,100),
     axes=T,
     xlab=T,
     ylab=T,
     cex=0,
     main = "Régions du monde échiquier")

polygon(x=c(0,100,100,0), y=c(0,0,100,100),col="lightyellow")


points(coo , 
      pch=15,
       col=clus,
       cex=0.9)


text(coo,
     row.names(coo),
     pos=3,
     cex=1,
     col=clus)

```


### Densités


Plusieurs méthodes sont possibles pour déterminer les trajectoires de regroupement des points en fonction d'une fonction d'interaction spatiale. Par exemple on peut utiliser comme dans le monde segmentaire la méthode des potentiels avec voisinages gaussiens de portées successives (5,10,15,20). On vot alors très bien comment le nombre de pics de potentiel (donc de densité) va progressivement diminuer pour passer de $n$ pics (nombre de positions occupées) pour
se réduite à un pic unique.
```{r}
library(potential)
library(mapsf)
library(sf)

# Delineate the world
lim = matrix(c(0,0,100,0,100,100,0,100,0,0),ncol=2, byrow=TRUE)
wld<-st_polygon(list(lim))


# Create a grid
gri <- create_grid(x = wld, res = 1)
#points(y$geometry, cex=0.1)
st_crs(gri) <-2154 # Arbitratry

# Transform point in sf
pop<-st_as_sf(coo, coords=c("X","Y"))
#points(pop)
st_crs(pop) <- 2154 # Arbitratry
pop$wgt<-1

# Compute distance between points and grid
d <- create_matrix(x = pop, y = gri,checksize = F,longlat = F)

# Compute potential

gri$pot3 <- potential(x = pop, y = gri, d = d,
                   var = "wgt", fun = "e",
                   span = 5, beta = 2)

gri$pot6 <- potential(x = pop, y = gri, d = d,
                   var = "wgt", fun = "e",
                   span = 10, beta = 2)

gri$pot12 <- potential(x = pop, y = gri, d = d,
                   var = "wgt", fun = "e",
                   span = 15, beta = 2)

gri$pot24 <- potential(x = pop, y = gri, d = d,
                   var = "wgt", fun = "e",
                   span = 20, beta = 2)
bks<-c(0, 0.1,0.2,0.4,0.8,1.6,3.2,6.4)

par(mfrow=c(2,2), mar=c(0,0,3,0))

# span=6
iso <- equipotential(x = gri, var = "pot3", breaks = bks)
#par(mar=c(0,0,3,0))
plot(coo, asp=1, xlab=NA,ylab=NA, axes=F, xlim=c(-1,101), ylim=c(-10,100), main = "k=5")
mf_map(x = iso, var = "min", type = "choro", 
       breaks = bks, 
       pal = rev(hcl.colors(10, 'Teal')),
       lwd = .2,
       border = "#121725", 
       leg_pos = "bottom",
       leg_val_rnd = 1,
       leg_horiz = T,
       leg_size = 0.5,
   #    leg_title = "Potential of\nPopulation",
       add=T)
points(coo,pch=20,col="black")
text(coo,row.names(coo),pch=20,col="black", pos=3, cex=0.6)



# span=6
iso <- equipotential(x = gri, var = "pot6", breaks = bks)
#par(mar=c(0,0,3,0))
plot(coo, asp=1, xlab=NA,ylab=NA, axes=F, xlim=c(-1,101), ylim=c(-10,100), main = "k=10")
mf_map(x = iso, var = "min", type = "choro", 
       breaks = bks, 
       pal = rev(hcl.colors(10, 'Teal')),
       lwd = .2,
       border = "#121725", 
       leg_pos = "bottom",
       leg_val_rnd = 1,
       leg_horiz = T,
       leg_size = 0.5,
   #    leg_title = "Potential of\nPopulation",
       add=T)
points(coo,pch=20,col="black")
text(coo,row.names(coo),pch=15,col="black", pos=3, cex=0.6)

# span=12
iso <- equipotential(x = gri, var = "pot12", breaks = bks)
#par(mar=c(0,0,3,0))
plot(coo, asp=1, xlab=NA,ylab=NA, axes=F, xlim=c(-1,101), ylim=c(-10,100), main = "k=15")
mf_map(x = iso, var = "min", type = "choro", 
       breaks = bks, 
       pal = rev(hcl.colors(10, 'Teal')),
       lwd = .2,
       border = "#121725", 
       leg_pos = "bottom",
       leg_val_rnd = 1,
       leg_horiz = T,
       leg_size = 0.5,
   #    leg_title = "Potential of\nPopulation",
       add=T)
points(coo,pch=20,col="black")
text(coo,row.names(coo),pch=20,col="black", pos=3, cex=0.6)
#mf_layout("k=6", frame=T, credits=NA, arrow=F, scale=F)

# span=12
iso <- equipotential(x = gri, var = "pot24", breaks = bks)
#par(mar=c(0,0,3,0))
plot(coo, asp=1, xlab=NA,ylab=NA, axes=F, xlim=c(-1,101), ylim=c(-10,100), main = "k=20")
mf_map(x = iso, var = "min", type = "choro", 
       breaks = bks, 
       pal = rev(hcl.colors(10, 'Teal')),
       lwd = .2,
       border = "#121725", 
       leg_pos = "bottom",
       leg_val_rnd = 1,
       leg_horiz = T,
       leg_size = 0.5,
   #    leg_title = "Potential of\nPopulation",
       add=T)
points(coo,pch=20,col="black")
text(coo,row.names(coo),pch=20,col="black", pos=3, cex=0.6)
#mf_layout("k=6", frame=T, credits=NA, arrow=F, scale=F)

```






## B.2 Le monde est un disque

![](img/discworld.jpg)

L'idée que le Monde soit un disque est une idée ancienne et même si la science a fini par l'infirmer elle demeure sans nul doute présente dans beaucoup de représentations contemporaines, propagées notamment par les théories du complot sur Youtube [@mohammed2019]. Il semble aussi que la conception d'une Terre plate soit une étape dans le dévloppement cognitif des enfants [@vaiopoulou2018]. Enfin, beaucoup de romans, notamment de science fiction ont utiliséce modèle pour construire des univers imaginaires, le plus célèbre étant sans doute celui des *Annales du Disque Monde* et la création annexe par l'auteur d'une série d'ouvrages portant sur la *Science of Discworld* [@stewart2011] .

> "*The Disc, as it’s referred to in the novel, is quite literally a disc. The flat planet is carefully balanced on the backs of four elephants – Berilia, Tubul, Great T’Phon, and Jerakeen – who in turn stand on the Star Turtle, the Great A’Tuin, as it swims through space. [...]  Since the Disc is flat, there are no cardinal directions. Instead, the four directions are Hubwards (towards the Hub), Rimwards (towards the Rim), Turnwise (the direction that the Disc rotates in), and Widdershins (opposite to Turnwise). This leads to an endless onslaught of puns and geographical jokes. At the end of the book we discover the Circumfence, the rope fence that lines the edge of the Disc to help ensure no one falls off. There’s also the beauty of the Counterweight Continent – a land fabled to be made out of pure gold that exists to keep the Disc from tipping over. Everything we learn about the geography of Discworld is strangely cohesive while being entirely silly.* "
Source : [Fernandez W., The Color of Magic, Consulté le 21/11/2024](https://wendyfernandez.net/2022/06/14/the-color-of-magic-an-introduction-to-sir-terry-pratchetts-discworld/)

Dans la perspective d'abstraction qui est la nôtre, un monde fini en forme de disque constitue un cas particulièrement intéressant puisque les positions peuvent y être mesurées par un jeu de coordonnées à la fois métrique et angulaire, ce qui revient en pratique à combiner les deux mondes vus précédemment : segment et cercle. 

### Données

On reprend les positions angulaires $\theta_1 ...\theta_{12}$ issues de la variable D1 et on ajoute 12 coordonnées de rayon $\rho_1 ...\rho_{12}$ qui mesurent la distance au centre. On fixe la distance maximale au centre à 1

```{r}
n=12
theta <- D1 *360/100
rho <- D2/100
coo<-data.frame(theta,rho)
row.names(coo)<-c("A","B","C","D","E","F",
                "G","H","I","J","K","L")
kable(coo)
```

### Visualisation

On peut propooser une visualisation planaire en projetant les coordonnées dans un espace euclidien à l'aide des formules de transformation des coordonnées polaires précédentes : 

$x_i = \rho_i \times cos(\theta_i)$

$y_i = \rho_i \times sin(\theta_i)$

```{r}
coo$Xi<-coo$rho*cos(pi*coo$theta/180)
coo$Yi<-coo$rho*sin(pi*coo$theta/180)
z<-seq(-pi, pi+0.1, 0.1)
zx<-cos(z)
zy<-sin(z)

par(mar = c(0,0,3,0), mfrow=c(1,1))
plot(coo$Xi,coo$Yi,   
     asp=1,
     ylim= c(-1, 1),
     xlim = c(-1,1),
     axes = F,
     xlab=NA,
     ylab=NA,
     
     main = "Le monde est un disque ...")
polygon(cbind(zx,zy),col="lightyellow")
points(coo$Xi, coo$Yi,
     pch=20,
     col="red",
     cex=2)
text(coo$Xi, coo$Yi,
     row.names(coo),
     pos=3,
     cex=0.8,
     col="black")
points(0,0, pch=3)


```

Mais en réalité, la propriété fondamentale d'un monde de ce type est qu'il n'existe pas de direction privilégiée de type "Nord", "Sud", "Est" ou "Ouest". Il y a en revanche un centre et une périphérie (définis par la position sur la coordonnée sur $\rho$) et une direction de rotation qui suit le sens trignométrique (valeurs croissantes de $\theta$) ou le sens des aiguilles d'une montre (valeurs décroissantes de $\theta$)

### Distances

Dans le monde du disque il existe de très nombreuses possibilités de mesurer les distances, conduisant chacune à des formes différentes de regroupement des points en fonction de leur proximité. D'une manière générale on peut écrire :

$D_{ij} = f(\rho_i, \theta_i, \rho_j, \theta_j)$

On peut par exemple imaginer une décomposition additive de la fontion $f$ en deux fonctions $f_1, f_2, f_3$ telles que  : 

$D_{ij}  = f_1(\rho_i,\rho_j) + f_2(\theta_i, \theta_j)$

On retrouve ainsi différences fonctions de distances utilisées en géographie urbaine : la distance centrale, la distance périphérique et la distance circumradiale  

La **distance centrale ** fait l'hypothèse que tous les déplacements doivent passer par le centre du disque en suivant les radiales. Ce qui donne :

$D_{ij}^{Ctr}  = \rho_i + \rho_j$


La **distance périphérique** fait l'hypothèse que tous les déplacements dovent passer par la bordure externe du disque car le centre est saturé.

$D_{ij}^{Per}  = (R - \rho_i)+ (R- \rho_j) + 2 \pi R \frac{|\theta_i-\theta_j|}{360}$


La **distance circumradiale** suppose quant à alle que les déplacements peuvent s'effectuer aussi bien à l'aide de radiales que de périphériques ce qui suppose que le réseau de transport combine les deux types d'axes. Elle constitue un équivalent de la distance de Manhattan mais appliquée à des villes de plan radioconcentriques comme Sfax. On peut la paramétrer à l'aide de coefficients $\alpha$ et $\beta$ pour tenir compte de vitesses différentes de circulation sur les radiales ou les périphériques. Elle possède la propriété d'admettre une infinité d'itinéraires différents puisque le plus court chemin peut s'effectuer selon différentes radiales ou différents périphériques.

$D_{ij}^{CR}  = \frac {\alpha|\rho_i - \rho_j| +  \beta \frac{ |\theta_i-\theta_j]|}{\pi}}{\alpha+\beta}$


```{r}
cooex<-coo[c(11,2),]
cooex$Xi<-cooex$rho*cos(pi*cooex$theta/180)
cooex$Yi<-cooex$rho*sin(pi*cooex$theta/180)
z<-seq(-pi, pi+0.1, 0.1)
zx<-cos(z)
zy<-sin(z)

## Radiale
par(mar = c(0,0,3,0), mfrow=c(1,3))
plot(cooex$Xi,cooex$Yi,   
     asp=1,
     ylim= c(-1, 1),
     xlim = c(-1,1),
     axes = F,
     xlab=NA,
     ylab=NA,
     
     main = "Distance centrale")
polygon(cbind(zx,zy),col="lightyellow")
points(cooex$Xi, cooex$Yi,
     pch=20,
     col="red",
     cex=2)
text(cooex$Xi, cooex$Yi,
     row.names(cooex),
     pos=3,
     cex=0.8,
     col="black")
points(0,0, pch=3)

segments(cooex$Xi[1],cooex$Yi[1],0,0,col='blue', lwd=2)
segments(cooex$Xi[2],cooex$Yi[2],0,0,col='blue',lwd=2)

## Périphérique
plot(cooex$Xi,cooex$Yi,   
     asp=1,
     ylim= c(-1, 1),
     xlim = c(-1,1),
     axes = F,
     xlab=NA,
     ylab=NA,
     
     main = "Distance périphérique")
polygon(cbind(zx,zy),col="lightyellow")
points(cooex$Xi, cooex$Yi,
     pch=20,
     col="red",
     cex=2)
text(cooex$Xi, cooex$Yi,
     row.names(cooex),
     pos=3,
     cex=0.8,
     col="black")
points(0,0, pch=3)

cooex$XR<-cos(pi*cooex$theta/180)
cooex$YR<-sin(pi*cooex$theta/180)

segments(cooex$Xi[1],cooex$Yi[1],cooex$XR[1],cooex$YR[1],col='red', lwd=2)
segments(cooex$Xi[2],cooex$Yi[2],cooex$XR[2],cooex$YR[2],col='red', lwd=2)
min<-cooex$theta[2]+360
max<-cooex$theta[1]
zz<-seq(min, max, -0.1)
zzx<-cos(pi*zz/180)
zzy<-sin(pi*zz/180)
lines(cbind(zzx,zzy),col="red",lwd=2)

## Circumradiale

plot(cooex$Xi,cooex$Yi,   
     asp=1,
     ylim= c(-1, 1),
     xlim = c(-1,1),
     axes = F,
     xlab=NA,
     ylab=NA,
     
     main = "Distance circumradiale")
polygon(cbind(zx,zy),col="lightyellow")
points(cooex$Xi, cooex$Yi,
     pch=20,
     col="red",
     cex=2)
text(cooex$Xi, cooex$Yi,
     row.names(cooex),
     pos=3,
     cex=0.8,
     col="black")
points(0,0, pch=3)

## Itinéraire n°1
cooex$XR<-cos(pi*cooex$theta/180)*mean(cooex$rho)
cooex$YR<-sin(pi*cooex$theta/180)*mean(cooex$rho)

segments(cooex$Xi[1],cooex$Yi[1],cooex$XR[1],cooex$YR[1],col='darkgreen', lwd=2)
segments(cooex$Xi[2],cooex$Yi[2],cooex$XR[2],cooex$YR[2],col='darkgreen', lwd=2)
min<-cooex$theta[2]+360
max<-cooex$theta[1]
z<-seq(min, max, -0.1)
zx<-cos(pi*z/180)*mean(cooex$rho)
zy<-sin(pi*z/180)*mean(cooex$rho)
lines(cbind(zx,zy),col="darkgreen",lwd=2)

## Itinéraire n°2
cooex$XR<-cos(pi*cooex$theta/180)*cooex$rho[1]
cooex$YR<-sin(pi*cooex$theta/180)*cooex$rho[1]

segments(cooex$Xi[1],cooex$Yi[1],cooex$XR[1],cooex$YR[1],col='darkgreen', lwd=1, lty=3)
segments(cooex$Xi[2],cooex$Yi[2],cooex$XR[2],cooex$YR[2],col='darkgreen', lwd=1, lty=3)
min<-cooex$theta[2]+360
max<-cooex$theta[1]
z<-seq(min, max, -0.1)
zx<-cos(pi*z/180)*cooex$rho[1]
zy<-sin(pi*z/180)*cooex$rho[1]
lines(cbind(zx,zy),col="darkgreen",lwd=1, lty=3)

## Itinéraire n°3
cooex$XR<-cos(pi*cooex$theta/180)*cooex$rho[2]
cooex$YR<-sin(pi*cooex$theta/180)*cooex$rho[2]

segments(cooex$Xi[1],cooex$Yi[1],cooex$XR[1],cooex$YR[1],col='darkgreen', lwd=1, lty=3)
segments(cooex$Xi[2],cooex$Yi[2],cooex$XR[2],cooex$YR[2],col='darkgreen', lwd=1, lty=3)
min<-cooex$theta[2]+360
max<-cooex$theta[1]
z<-seq(min, max, -0.1)
zx<-cos(pi*z/180)*cooex$rho[2]
zy<-sin(pi*z/180)*cooex$rho[2]
lines(cbind(zx,zy),col="darkgreen",lwd=1, lty=3)


```


Essayons à titre d'exemple de la calculer la distance circumradiale pour les paramètres $\alpha = \beta = 1$, c'est-à-dire en accordant la même importance aux différences angulaires et aux différences radiales.

```{r}
mat<-matrix(,nrow=12,ncol=12)




disCR<-function(r1,r2,t1,t2){
    difrho <-abs(r1-r2)
    diftheta <- abs(t1-t2)
    diftheta <- min(diftheta, 360-diftheta)/180
    res<-(difrho + diftheta)/2
    return(res)
}


## Distance circumradiale
DCR<-mat  
for(i in 1:12){
  for(j in 1:12){
    DCR[i,j]<-disCR(rho[i],rho[j],theta[i],theta[j])
  }
}



row.names(DCR)<-row.names(coo)
colnames(DCR)<-row.names(coo)

kable(DCR, caption = "Distance circumradiale", digits=2)


```


### Partition

```{r}
DCR<-as.dist(DCR)
par(mfrow=c(1,1))
reg<-hclust(DCR)
plot(reg,hang = -1,
     labels = row.names(coo),
     main = "Classification en distance circumradiale",
     xlab = "Positions",
     ylab = "Distance circumradiale (1,1)")
```

L'arbre nous suggère 4 classes que l'on peut visualiser ainsi

```{r}
clus<-cutree(reg,k=4)

z<-seq(-pi, pi+0.1, 0.1)
zx<-cos(z)
zy<-sin(z)

par(mar = c(0,0,3,0), mfrow=c(1,1))
plot(coo$Xi,coo$Yi,   
     asp=1,
     ylim= c(-1, 1),
     xlim = c(-1,1),
     axes = F,
     xlab=NA,
     ylab=NA,
     
     main = "Régions du disque-monde ...")
polygon(cbind(zx,zy),col="lightyellow")
points(coo$Xi, coo$Yi,
     pch=20,
     col=clus,
     cex=2)
text(coo$Xi, coo$Yi,
     row.names(coo),
     pos=3,
     cex=0.8,
     col=clus)
points(0,0, pch=3)

```

L'image obtenu est de prime abord assez perturbante puisque des points qui nous semblent proches (en distance euclidienne) se retouvent en fait séparés dans des classes différentes et des points apparemment éloignés sont regroupés. La difficulté vient du fait que notre oeil regroupe de façon euclidienne alors que la distance qui est ici à l'oeuvre (circumradiale) opère différemment. Elle conduit en particulier à rapprocher les points localisés dans un même secteur angulaire c'est-à-dire ayant des valeurs proches de $\theta$. Deux points centraux peuvent alors être très éloignés s'ils sont situés de part et d'autre du centre.

### Densité

Le calcul des densités avec cette géométrie pour différentes portées de lissage est assez complexe ... Nous procédons ici juste à un calcul approximatif pour des voisinages gaussiens de portée 0.1 et 0.2 en distance circumradiale.

```{r}
pts_theta<-rep(seq(0,360,1),21)
pts_rho <-rep(seq(0,1,0.05),361)
mat<-matrix(,nrow=7581, ncol=12)

disCR<-function(r1,r2,t1,t2){
    difrho <-abs(r1-r2)
    diftheta <- abs(t1-t2)
    diftheta <- min(diftheta, 360-diftheta)/180
    res<-(difrho + diftheta)/2
    return(res)
}


for(i in 1:7581){
  for (j in 0:12){
    mat[i,j]<-disCR(pts_rho[i],rho[j],pts_theta[i],theta[j])
  }
}
alpha=log(0.5)/((0.1)**2)
pot<-exp(alpha*mat**2)
pot10<-apply(pot,1,sum)

alpha=log(0.5)/((0.2)**2)
pot<-exp(alpha*mat**2)
pot20<-apply(pot,1,sum)



mypts<-data.frame(rho=pts_rho,theta=pts_theta,pot10, pot20)
mypts$X<-mypts$rho*cos(pi*mypts$theta/180)
mypts$Y<-mypts$rho*sin(pi*mypts$theta/180)



m<-mean(mypts$pot10)
mypts$col10<-cut(mypts$pot10,breaks=c(0,0.1,0.2,0.5,1,2,5)) 
levels(mypts$col10)<-c("blue","lightblue","lightgreen","lightyellow","orange","red")
mypts$col10<-as.character(mypts$col10)

m<-mean(mypts$pot20)
mypts$col20<-cut(mypts$pot20,breaks=c(0,0.1,0.2,0.5,1,2,5)) 
levels(mypts$col20)<-c("blue","lightblue","lightgreen","lightyellow","orange","red")
mypts$col20<-as.character(mypts$col20)

par(mar = c(0,0,3,0), mfrow=c(1,2))

# Portée 0.1
plot(mypts$X,mypts$Y, 
     cex=mypts$rho*2+2, 
     pch=20, 
     axes=F,
     asp=1,
     col=mypts$col10,
     main = "Voisinage gaussien (0.1)")
points(coo$Xi, coo$Yi,
     pch=20,
     col="black",
     cex=2)
text(coo$Xi, coo$Yi,
     row.names(coo),
     pos=3,
     cex=0.8,
     col="black")
points(0,0, pch=3)

# Portée 0.2
plot(mypts$X,mypts$Y, 
     cex=mypts$rho*2+2, 
     pch=20, 
     axes=F,
     asp=1,
     col=mypts$col20,
     main = "Voisinage gaussien (0.2)")
points(coo$Xi, coo$Yi,
     pch=20,
     col="black",
     cex=2)
text(coo$Xi, coo$Yi,
     row.names(coo),
     pos=3,
     cex=0.8,
     col="black")
points(0,0, pch=3)
```


Les couleurs sont calculées en fonction de la valeur du potentiel selon une échelle multiplicative. On remarque que des zones très proches du centre (ex. voisinage du point C) peuvent avoir des densités très faibles car elles ont peu d'autres points dans leur secteur angulaire. Inversement des points apparamment éloignés mais proches en terme angulaire ou en terme de distance au centre peuvent créer des pics locaux(cas des points B et D).


**N.B.** : J'ai l'impression de réinventer la lune faute de recherches bibliographiques suffisante. Mais *who knows* ? 




## B.3 Le monde est un triangle 

![[source](http://www.quartzpage.de/app_td.html)](img/ternary.jpg)

Les diagrammes triangulaires aussi appelés ternaires (*ternary diagram*) correspondent à un cas particulier de monde bidimensionnel mais construit à partir de trois variables liées par une relation. qui fait que chacune des variables peut se déduire des deux autres. On posera plus précisément que la somme des trois composantes doit toujours être égale à 1 pour chacun des éléments de la population décrit par les rois composantes.

$\forall i \in \{1,n\} \space \space   D_1(i) + D_2(i) + D_3(i) = 1$

Ce type de diagramme a été par exemple utilisé en minéralogie pour décrire la composition de roches composées de trois types de minéraux. Ou bien en économie dans la théorie de Rostow pour décrire le passage d'une économie du secteur primaire au secteur secondaire et finalement tertiaire. 

Dans une perspective plus abstraite, la géométrie ternaire est une variante intéressante du monde de l'échiqier qui possède certaines propriétés singulières. 

### Données

Pour construire un monde triangulaire, nous allons transformer nos trois dimensions initiales $D_1, D_2, D_3$ en coordonnées $x,y,z$ en appliquant les transformations suivantes : 

$$
\left\{
    \begin{array}{lll}
        x_i = \frac{D_1(i)}{D_1(i)+D_2(i)+D_3(i)}  \\
        y_i = \frac{D_2(i)}{D_1(i)+D_2(i)+D_3(i)}  \\
        z_i = \frac{D_3(i)}{D_1(i)+D_2(i)+D_3(i)}   
    \end{array}
\right.
$$

Mais on peut aussi considérer s'il n'y a que deux dimensions **finies** que la troisième coordonnée est la moyenne des complémentaire des deux précédentes, ce qui donne :

$$
\left\{
    \begin{array}{lll}
        \omega(i) = \frac{(max(D_1)-D_1(i)) + (max(D_2)-D_2(i))}{2}\\
        x_i = \frac{D_1(i)}{D_1(i)+D_2(i)+\omega(i)}  \\
        y_i = \frac{D_2(i)}{D_1(i)+D_2(i)+\omega(i)}  \\
        z_i = \frac{D_3(i)}{D_1(i)+D_2(i)+\omega(i)}   
    \end{array}
\right.
$$



Dans notre exemple, les deux dimensions $D_1$ et $D_2$ ont chacune un maximum de 100 de sorte qu'on peut en déduire facilement une troisième coordonnée sans faire intervenir une dimension supplémentaire

```{r}
Omega <- (200-D1-D2)/2
x = D1/(D1+D2+Omega)
y = D2/(D1+D2+Omega)
z = Omega/(D1+D2+Omega)
coo<-data.frame(x,y,z)
row.names(coo)<-code
kable(coo, digits=2, caption = "Coordonnées triangulaires")
```


### Visualisation

Compte-tenu des spécificités des liaisons entre les trois coordonnées (métrique oblilinéaire), il est préférable de faire appel à des packages spécialisés pour visualiser les points dans ce type de géométrie. 

::: {.callout-note title="Visualisation de diagrammes ternaires dans R" collapse="true"}
Il existe un grand nombre de packages dédiés à la visualisation de diagramme ternaires dans R, parmi lesquels on peut citer `ggtern`, `plotly`et `Ternary`. Le choix de l'un ou l'autre de ces packages dépend des objectifs poursuivis. Nous optons ici pour le package `Ternary`qui offre de nombreuses possibilités de visualisation mais aussi de traitement.

- [ggtern](http://www.ggtern.com/d/2.2.0/) est une extension de `ggplot2` mise au point par Nicholas Hamilton et est donc bien adapté à des visualisations statiques pour les personnes habituées à la logique de ggplot2.
- [plotly](https://plotly.com/r/ternary-plots/) permet grâce à son type d'objet `scatterternary`de construire des diagrammes ternaires dynamiques bien adaptés au web. Mais il comporte également des outils assez raffinés de délimitation de lignes ou de zones à l'intérieur de ces diagrammes.
- [Ternary](https://cran.r-project.org/web/packages/Ternary/vignettes/Ternary.html) semble enfin le plus prometteur pour notre objectif car il offre non seulement des possibilités de visualisation mais aussi de traitement, notamment pour le calcul de densités et le tracé des isolignes associées. 

Mais il en existe sans nul doute d'autres ...
:::


```{r}
par(mfrow=c(1,1), mar=c(0,0,3,0))
TernaryPlot(col = "lightyellow",
            axis.col = "gray60",
            alab=expression('x'%->%''),
            blab=expression('y'%->%''),
            clab=expression(''%<-%'z')
            )
title("Le monde est un triangle...", cex.main = 1)
TernaryPoints(coo,col="red",pch=17,cex=1)
TernaryText(coo,labels=row.names(coo),pos=2,col="red", cex=0.8)
```



### Distance

Il existe de nombreuses distances possibles dans un triangle, mais l'une des plus logique semble être la *distance oblilinéaire* qui corresspond au plus court chemin en ne se déplaçant que selon l'une des trois directions du triangle. La distance sera plus ou moins longue selon que l'on passe  par les axes $(x,y)$, $(y,z)$ ou $(x,z)$. On choisira donc la distance la plus courte parmi les trois types d'itinéraires

$D^{xy}(i,j) = |x_i-x_j| + |y_i-y_j|$

$D^{yz}(i,j) = |y_i-y_j| + |z_i-z_j|$

$D^{xz}(i,j) = |x_i-x_j| + |z_i-z_j|$

$D_{min}^{xyz}(i,j) = min(D^{xy}(i,j), D^{yz}(i,j), D^{xz}(i,j))$


Par exemple si on considère les point $i(0,50,50)$ et le point $j(50,20,30)$ on a :

$D^{xy}(i,j) = |0-50| + |50-20|  = 80$

$D^{yz}(i,j) = |50-20| + |50-30| = 50$

$D^{xz}(i,j) = |0-50| + |50-30| = 70$

$D_{min}^{xyz}(i,j) = min(80, 50, 70) = 50$

Le plus court chemin est donc ici celui qui emprunte les axes $y$ et $z$ mais, comme dans le cas de la distance de Manhattan, il existe une infinité d'itinéraires possibles entre les deux points qui respectent la condition de plus court chemin et qui correspondent à un trapèze.

```{r}
par(mfrow=c(1,1), mar=c(0,0,3,0))
TernaryPlot(col = "lightyellow",
            axis.col = "gray60",
            alab=expression('x'%->%''),
            blab=expression('y'%->%''),
            clab=expression(''%<-%'z')
            )
title("Plus court chemin en distance oblilinéaire", cex.main = 1)
ex <- matrix(c(0,50,50, 20,50,30), ncol=3)
names(ex)<-c("x","y","z")
row.names(ex)=c("i","j")
ex<-data.frame(ex)
TernaryPoints(ex,col="red",pch=17,cex=1)
TernaryText(ex,labels=row.names(ex),pos=2,col="red", cex=0.8)

TernaryLines(list(c(0,50,50),c(20,50,30)), col="blue", lwd=2)
TernaryLines(list(c(20,50,30),c(50,20,30)), col="blue", lwd=2)

TernaryLines(list(c(0,50,50),c(30,20,50)), col="blue", lwd=2, lty=3)
TernaryLines(list(c(30,20,50),c(50,20,30)), col="blue", lwd=2, lty=3)

TernaryPolygon(list(c(0,50,50),
                    c(20,50,30),
                    c(50,20,30), 
                    c(30,20,50),
                    c(0,50,50)),
               border=NA,
               col=  adjustcolor("blue", alpha.f = 0.2),
               
               )

```


La matrice de distance entre nos 12 points pour cette métrique de plus court chemin oblilinéaire est la suivante 

```{r}
Dxy<-as.matrix(dist(coo[,1:2],method = "manhattan",upper = T, diag =T))
Dyz<-as.matrix(dist(coo[,2:3],method = "manhattan",upper = T, diag =T))
Dxz<-as.matrix(dist(coo[,c(1,3)],method = "manhattan",upper = T, diag =T))
Dxyz<-Dxy
for (i in 1:12){
  for(j in 1:12){
    Dxyz[i,j] <- min(Dxy[i,j], Dyz[i,j],Dxz[i,j])
  }
}

kable(Dxyz, digits=2, caption = "Distance oblilinéaire")
```

### Partition

```{r}
DOB<-as.dist(Dxyz)
par(mfrow=c(1,1))
reg<-hclust(DOB)
plot(reg,hang = -1,
     labels = row.names(coo),
     main = "Classification en distance oblilinéaire",
     xlab = "Positions",
     ylab = "Distance oblilinéaire")
```

L'arbre nous suggère 3 classes que l'on peut visualiser ainsi : 


```{r}

clus<-cutree(reg,k=3)

par(mfrow=c(1,1), mar=c(0,0,3,0))
TernaryPlot(col = "gray98",
            axis.col = "gray60",
            alab=expression('x'%->%''),
            blab=expression('y'%->%''),
            clab=expression(''%<-%'z')
            )
title("Régions du monde triangulaire", cex.main = 1)
TernaryPoints(coo,col=clus,pch=17,cex=1)
TernaryText(coo,labels=row.names(coo),pos=2,col=clus, cex=0.8)
```


### Densité

Le package `Ternary` offre a première vue une fonction de calcul des densités ce qui facilité l'analyse des pics de concentration à différentes échelles selon un paramètre bandwidth (Bw). 

```{r}
par(mfrow=c(1,2), mar=c(0,0,3,0))



mypal<-rev(brewer.pal(n = 11,name = "RdYlBu")[1:8])
## Fig1

TernaryPlot(col = "gray98",
            axis.col = "gray60",
            alab=expression('x'%->%''),
            blab=expression('y'%->%''),
            clab=expression(''%<-%'z')
            )
title("Bw = 0.20", cex.main = 1)
TernaryDensityContour(coo, bandwidth=0.20,
                      resolution = 50L,
                      filled=T,fill.col = mypal,
                     nlevels = 6)
TernaryPoints(coo,col="red",pch=17,cex=1)

TernaryPlot(col = "gray98",
            axis.col = "gray60",
            alab=expression('x'%->%''),
            blab=expression('y'%->%''),
            clab=expression(''%<-%'z')
            )
title("Bw = 0.40", cex.main = 1)
TernaryDensityContour(coo, bandwidth=0.4,
                      resolution = 50L,
                      filled=T,fill.col = mypal,
                     nlevels = 6)
TernaryPoints(coo,col="red",pch=17,cex=1)


```

On repère bien sur les deux figures la façon dont s'opère la fusion des pics de densité et la possibilité que cela offre de définir des régionalisations multi-scalaires.  Mais il faudrait vérifier si le package utilise bien la distance oblilinéaire plutôt qu'une simple distance euclidienne ce qui ne serait pas logique par rapport aux hypothèses précédentes. Or, on a bien l'impression au vu des figures que le calcul est effectué en distance euclidienne puisque des cercles apparaissent autour des points isolés. 


## B.4 Le monde est un tore

![[Source : Wyrd Smythe, 2021, Flat Space of Torus](https://logosconcarne.com/2021/08/30/flat-space-of-the-torus/)](img/torus-earth.png)


```{r}
library(plot3D)
par(mfrow=c(1,2))

# Torus
R <- 2; r <- 2
M <- mesh(seq(0, 2*pi,length.out=50), seq(0, 2*pi,length.out=50))

alpha <- M$x; beta <- M$y

x <- (R + r*cos(alpha)) * cos(beta)
y <- (R + r*cos(alpha)) * sin(beta)
z <-  r * sin(alpha)

surf3D(x = x, y = y, z = z, colkey=FALSE, bty="b2",
       phi = 50, theta = 30, main="Tore (vue 3D)")

# Half Torus
R <- 2; r <- 2
M <- mesh(seq(0, 2*pi,length.out=50), seq(0, pi,length.out=50))

alpha <- M$x; beta <- M$y

x <- (R + r*cos(alpha)) * cos(beta)
y <- (R + r*cos(alpha)) * sin(beta)
z <-  r * sin(alpha)

surf3D(x = x, y = y, z = z, colkey=FALSE, bty="b2",
       phi = 40, theta = 20, main="Tore (coupe)")
```


::: {.callout-note title="Le tore comme variété à deux dimensions" collapse="true"}

> La nature circulaire des angles fait que l'angle bivarié $(\theta,\phi)$ est sur le tore, qui peut être intégré comme une variété (*manifold*) bidimensionnelle dans $R^3$, et peut être coupé et aplati comme un carré $T^2 = [-\pi,\pi) \times [-\pi,\pi)$ sur $R^2$. Par conséquent, un $(-\pi,-\pi)$ est plus proche de $(\pi - \epsilon ,\pi - \epsilon )$ que $(-\pi +2 ,-\pi +2 )$ pour un certain $\epsilon >0$. En raison de cette contrainte géométrique, la plupart des méthodes de clustering prêtes à l'emploi ne sont pas applicables, du moins pas sans une adaptation appropriée. 

Source : @jung2021

:::


### Données

Comme dans le cas du monde circulaure On transforme les coordonnées $D_1$ en positions angulaires sur le cercle dans le sens trigonométrique $\theta_1 ...\theta_{12}$ et on effectue la même opération pour $D_2$ afin d'obtenir un second jeu de coordonnées $\phi_1 ...\phi_{12}$ comprises dans l'intervalle $[-\pi ; +\pi]$ (ou $[0; 2\pi]$ ce qui revient au même). Comme nos dimension avaient été tirées au sort sur l'intervalle $[0 ; 100]$ on applique la transformation suivante :

$\theta(i) = \frac{2 \pi D_1(i)}{100}-\pi$
$\phi(i) = \frac{2 \pi D_2(i)}{100}-\pi$


```{r}
theta <- 2*pi*D1/100 -pi
phi <- 2*pi*D2/100 -pi
coo<-data.frame(theta, phi)
row.names(coo)<-c("A","B","C","D","E","F",
                "G","H","I","J","K","L")
kable(coo, caprion = "Coordonnées angulaires bidimensionnelles en radian")
```


### Visualisation

Comme il est difficile de produire une visualisation d'un tore en trois dimensions sans que certains points soient cachés, on va utiliser ici une représentation en deux dimensions qui semble identique visuellement à celle monde de l'échiquier mais qui doit s'interpréter différemment.


```{r}

par(mar=c(4,4,4,4),  mfrow=c(1,1))
plot(coo ,  
     asp=1,
     ylim= c(-pi, pi),
     xlim = c(-pi,pi),
     ylab="Theta",
     xlab="Phi",
     axes=T,
     cex=0,
     main = "Le monde est un tore ...")



polygon(x=c(-pi,pi,pi,-pi), y=c(-pi,-pi,pi,pi),col="lightyellow")



points(coo , 
      pch=15,
       col="red",
       cex=0.9)


text(coo,
     row.names(coo),
     pos=3,
     cex=1,
     col="black")


```

> Figures à améliorer en réduisant les coordonnées à -pi / +pi et en éliminant la marge

### Distance

On peut utiliser la fonction du package `circular`utilisées précédement pour calculer les distances sur le cercle en l'appliquant à chacune des dimensions. On obtient alors une distance $D^\theta$ et une distance $D^\phi$ que l'on peut combiner de différentes façons pour construire une distance sur le tore. La solution la plus simple est évidemment de les additionner ce qui revient à une forme de distance orthogonale sur le tore, analogue à la distance de Manhattan dans un plan euclidien avec une distance maximale égale à $2\pi$

$D^{orth}(i,j) = |\theta_i-\theta_j| +|\phi_i-\phi_j|$

Mais on peut également essayer de construire une distance équivalente à la distance euclidienne qui impliquerait des déplacements en oblique sur le tore déplié et serait alors plus courte que la distance de Manhattan. Cette solution revient à calculer la distance angulaire dans un espace à p dimensions.

$D^{Ang}(i,j) = |\widehat{i,j}|$

La valeur maximale de distance angulaire est alors égale à $2\pi/\sqrt{2}$. On peut facilement calculer cette distance angulaire à l'aide de la fonction `ang.pdist` du package **ClusTorus** proposé par @jung2021.


Pour illustrer ces deux distances, considérons à titre d'exemple les points $C$ et $J$ situés respectivement en bas à gauche et enhaut à droite de la figure précédente. A première vue ils semblent très éloignés (dans un monde de type échiquier) mais ils sont en fait très proche dans la géométrie du tore où l'on ressort d'un côté pour rentrer par l'autre.

```{r}
ptC<-coo[3,]
ptJ<-coo[10,]
coo2<-rbind(ptC,ptJ)

par(mar=c(0,0,3,0), mfrow=c(1,2))

# Rectilinéaire
plot(coo2 ,  
     asp=1,
     ylim= c(-pi, pi),
     xlim = c(-pi,pi),
     ylab="Theta",
     xlab="Phi",
     axes=F,
     cex=0,
     main = "Distances rectlinéaire")



polygon(x=c(-pi,pi,pi,-pi), y=c(-pi,-pi,pi,pi),col="lightyellow")



points(coo2 , 
      pch=15,
       col="black",
       cex=0.9)


text(coo2,
     row.names(coo2),
     pos=3,
     cex=1,
     col="black")

arrows(coo2[1,1], coo2[1,2],coo2[1,1],-pi,
       col="blue",length = 0.1,lwd=2)
arrows(coo2[1,1], pi,coo2[1,1],coo2[2,2],
       col="blue",length=0.1,lwd=2)
arrows(coo2[1,1],coo2[2,2],-pi,coo2[2,2],
       col="blue",length=0.1,lwd=2)
arrows(pi,coo2[2,2],coo2[2,1],coo2[2,2],
       col="blue",length=0.1,lwd=2)

# Angulaire

plot(coo2 ,  
     asp=1,
     ylim= c(-pi, pi),
     xlim = c(-pi,pi),
     ylab="Theta",
     xlab="Phi",
     axes=F,
     cex=0,
     main = "Distances angulaire")



polygon(x=c(-pi,pi,pi,-pi), y=c(-pi,-pi,pi,pi),col="lightyellow")



points(coo2 , 
      pch=15,
       col="black",
       cex=0.9)


text(coo2,
     row.names(coo2),
     pos=3,
     cex=1,
     col="black")
dy = (pi+coo2[1,2] + pi-coo2[2,2])/2
dx = (pi+coo2[1,1] + pi-coo2[2,1])/2
dev<-(dy/dx)*pi+coo2[1,1]


arrows(coo2[1,1], coo2[1,2],coo2[1,1]+dev,-pi,
       col="red",length = 0.1,lwd=2)

arrows(coo2[1,1]+dev, pi,-pi,pi+dev,
       col="red",length = 0.1,lwd=2)

arrows(pi, pi+dev,coo2[2,1],coo2[2,2],
       col="red",length = 0.1,lwd=2)
```


Si on retient la distance angulaire et qu'on la normalise en la divisant par $2\pi/\sqrt(2)$ pour arriver à une distance maximale de 1, la matrice de distance entre nos points est la suivante :

```{r}
DD<-ang.pdist(coo)
matDD<-as.matrix(DD)/(2*pi/sqrt(2))
colnames(matDD)<-row.names(coo)
rownames(matDD)<-row.names(coo)
kable(matDD, caption = "Distance orthogonale sur le tore", digits=3)
```



### Partition

```{r}
par(mfrow=c(1,1))

reg<-hclust(as.dist(matDD))
plot(reg,hang = -1,
     labels = row.names(coo),
     main = "Classification en distance angulaire",
     xlab = "Positions",
     ylab = "Distance angulaire")
```

L'arbre nous suggère 4 classes que l'on peut visualiser ainsi

```{r}
clus<-cutree(reg,k = 4)

par(mar=c(4,4,4,4),  mfrow=c(1,1))
plot(coo ,  
     asp=1,
     ylim= c(-pi, pi),
     xlim = c(-pi,pi),
     ylab="Theta",
     xlab="Phi",
     axes=T,
     cex=0,
     main = "Régions du monde tore")



polygon(x=c(-pi,pi,pi,-pi), y=c(-pi,-pi,pi,pi),col="lightyellow")



points(coo , 
      pch=15,
       col=clus,
       cex=0.9)


text(coo,
     row.names(coo),
     pos=3,
     cex=1,
     col=clus)


```


La figure montre notamment un groupe régional composé des points $(B,C,L)$ qui semble contre-intuitif pour un regard habitué au monde-échiquier mais qui est parfaitement logique dans une monde en forme de tore. 

### Densité


```{r}

par(mar=c(0,0,3,0), mfrow=c(1,2))

# kappa = 6
mygrid<-grid.torus(d=2,grid.size = 100 )
mygrid<-mygrid-pi
x<-kde.torus(coo,mygrid,concentration = 6)
x<-x/mean(x)
mycol<-cut(x, breaks= c(0,0.125,0.25, 0.5,1,2,4,8,max(x)))
mypal<-rev(brewer.pal(8,"RdYlBu"))
levels(mycol)<-mypal
mycol<-as.character(mycol)


plot(mygrid, 
     cex=1, 
     pch=20,
     col=mycol,
     asp=1, 
     axes=F,
     xlab=NA,
     ylab=NA,
     main="kappa=6")
points(coo , 
      pch=15,
       col="black",
       cex=0.9)
text(coo,
     row.names(coo),
     pos=3,
     cex=1,
     col="black")

# kappa = 3
mygrid<-grid.torus(d=2,grid.size = 100 )
mygrid<-mygrid-pi
x<-kde.torus(coo,mygrid,concentration = 3)
x<-x/mean(x)
mycol<-cut(x, breaks= c(0,0.125,0.25, 0.5,1,2,4,8,max(x)))
mypal<-rev(brewer.pal(8,"RdYlBu"))
levels(mycol)<-mypal
mycol<-as.character(mycol)


plot(mygrid, 
     cex=1, 
     pch=20,
     col=mycol,
     asp=1, 
     axes=F,
     xlab=NA,
     ylab=NA,
     main="kappa=3")
points(coo , 
      pch=15,
       col="black",
       cex=0.9)
text(coo,
     row.names(coo),
     pos=3,
     cex=1,
     col="black")
```



## B.5 Le monde est une sphère


# C. MONDES RETICULAIRES

## D.1 Le monde est un graphe planaire

## D.1 Le monde est un graphe non planaire

# ANNEXES

## Bibliographie
